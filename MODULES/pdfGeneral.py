# Importez les bibliothèques nécessaires
import io
import MODULES
from markdown import markdown
from md2pdf.core import md2pdf as md2pdfmodule
from weasyprint import HTML
import MODULES.searchsploitCli as searchsploit


def list2graphical(varlist):
    # Cette fonction prend une liste de variables en entrée et retourne une représentation graphique de cette liste sous forme de chaîne de caractères.

    returnlist = ''  # Initialisation d'une variable pour stocker la chaîne de caractères résultante

    for ligne in varlist:  # Boucle "for" pour parcourir chaque élément de la liste "varlist"
        returnlist += (
                '- ' + ligne + ' \n')  # Ajout d'un tiret ("-") suivi de l'élément de la liste à la variable "returnlist" et ajout d'une nouvelle ligne (\n) pour passer à la ligne suivante.

    return returnlist  # Retourne la variable "returnlist" qui contient la représentation graphique de la liste sous forme de chaîne de caractères.


def dict2bckreturn(varlist):
    # Cette fonction prend une liste de dictionnaires en entrée et retourne une représentation graphique de chaque dictionnaire sous forme de chaîne de caractères.

    returnvalue = ''  # Initialisation d'une variable pour stocker la chaîne de caractères résultante

    for ligne in varlist:  # Boucle "for" pour parcourir chaque dictionnaire de la liste "varlist"
        # Ajout des valeurs de chaque clé du dictionnaire à la variable "returnvalue" sous forme de chaîne de caractères
        # Les clés utilisées sont 'port', 'protocol', 'product' et 'version'
        # La méthode 'format' permet d'insérer les valeurs de chaque clé dans une chaîne de caractères
        returnvalue += (
            '{port}/{protocol}:{product}-{version}<br>'.format(port=ligne['port'], protocol=ligne['protocol'],
                                                               product=ligne['product'], version=ligne['version']))
    return returnvalue  # Retourne la variable "returnvalue" qui contient la représentation graphique de chaque dictionnaire sous forme de chaîne de caractères.


def nmap_dictionarisation(nm):
    # Cette fonction prend un objet nmap en entrée et retourne une liste de dictionnaires qui représentent chaque service détecté par Nmap.

    services = []  # Initialisation d'une liste pour stocker les dictionnaires de services détectés

    for host in nm.all_hosts():  # Boucle "for" pour parcourir chaque hôte analysé par Nmap
        for protocol in nm[host].all_protocols():  # Boucle "for" pour parcourir chaque protocole utilisé par l'hôte
            lport = nm[host][protocol].keys()  # Récupération des ports ouverts pour l'hôte et le protocole actuels
            for port in lport:  # Boucle "for" pour parcourir chaque port ouvert
                # Récupération des informations du service détecté pour l'hôte, le protocole et le port actuels
                product = nm[host][protocol][port]['product']
                version = nm[host][protocol][port]['version']
                state = nm[host][protocol][port]['state']
                # Ajout d'un nouveau dictionnaire à la liste "services" contenant toutes les informations du service détecté
                services.append(
                    {'ip': host, 'nom': nm[host].hostname(), 'port': port, 'protocol': protocol, 'product': product,
                     'version': version})

    return services  # Retourne la liste "services" contenant les dictionnaires de chaque service détecté par Nmap.


def nmap2table(nm):
    # Cette fonction prend un objet nmap en entrée et retourne une chaîne de caractères contenant un tableau HTML qui affiche les informations de chaque service détecté par Nmap.

    returnlist = ''  # Initialisation d'une chaîne de caractères vide pour stocker le tableau HTML final
    services = []  # Initialisation d'une liste pour stocker les dictionnaires de services détectés

    for host in nm.all_hosts():  # Boucle "for" pour parcourir chaque hôte analysé par Nmap
        for protocol in nm[host].all_protocols():  # Boucle "for" pour parcourir chaque protocole utilisé par l'hôte
            lport = nm[host][protocol].keys()  # Récupération des ports ouverts pour l'hôte et le protocole actuels
            for port in lport:  # Boucle "for" pour parcourir chaque port ouvert
                # Récupération des informations du service détecté pour l'hôte, le protocole et le port actuels
                product = nm[host][protocol][port]['product']
                version = nm[host][protocol][port]['version']
                state = nm[host][protocol][port]['state']
                # Ajout d'un nouveau dictionnaire à la liste "services" contenant toutes les informations du service détecté
                services.append({'port': port, 'protocol': protocol, 'product': product, 'version': version})

        # Ajout d'une nouvelle ligne au tableau HTML pour chaque hôte, contenant l'adresse IP, le nom d'hôte et les informations des services détectés
        returnlist += (
            '| {ip}| {nom}| {services}|\n'.format(ip=host, nom=nm[host].hostname(), services=dict2bckreturn(services)))

    return returnlist  # Retourne la chaîne de caractères contenant le tableau HTML complet


def vulnnmap(nmap):
    resultlist = {}  # Créer un dictionnaire pour stocker les résultats des vulnérabilités
    for scan in nmap_dictionarisation(nmap):  # Boucle sur les résultats de la fonction nmap_dictionarisation()
        if scan['product'] or scan['version']:  # Vérifier si les informations sur le produit ou la version existent
            exploitformat = scan['product'] + ' ' + scan['version'].split(' ')[
                0]  # Formater les informations d'exploitation à partir des informations de produit et de version
            # exploitformat = "OpenSSH 7.0P1"
            vulnlist = [vuln['titre'] + ' : ' + vuln['type'] for vuln in searchsploit.exploitdbSearch(
                exploitformat)]  # Rechercher les vulnérabilités connues dans la base de données d'exploits
            if scan['nom']:  # Vérifier si le nom d'hôte existe
                resultlist['{ip}:{port} {service} - {nom}'.format(nom=scan['nom'], ip=scan['ip'], port=scan['port'],
                                                                  service=(
                                                                      exploitformat))] = vulnlist  # Ajouter les résultats au dictionnaire, en utilisant le nom d'hôte si disponible
            else:
                resultlist['{ip}:{port} {service}'.format(ip=scan['ip'], port=scan['port'], service=(
                    exploitformat))] = vulnlist  # Ajouter les résultats au dictionnaire, sans utiliser le nom d'hôte
        else:
            resultlist['{ip}:{port} unknown'.format(ip=scan['ip'], port=scan[
                'port'])] = ''  # Si les informations sur le produit ou la version sont manquantes, ajouter une entrée "unknown" au dictionnaire
    return resultlist  # Retourner le dictionnaire de résultats des vulnérabilités


def simplify_vulnnmap(vulnnmap):
    resultdict = {}  # Initialisation d'un dictionnaire vide qui va contenir le résultat simplifié
    for key, value in vulnnmap.items():  # Itération sur chaque élément du dictionnaire de vulnérabilités
        resultlist = []  # Initialisation d'une liste vide qui va contenir les vulnérabilités simplifiées pour un élément donné
        if value:  # Si la valeur du dictionnaire n'est pas vide, on simplifie les vulnérabilités
            resultlist = [vuln.split(':')[0] for vuln in
                          value]  # Simplification des vulnérabilités pour l'élément courant
            resultdict[key] = list(dict.fromkeys(
                resultlist))  # Ajout des vulnérabilités simplifiées pour l'élément courant dans le dictionnaire de résultat
    return resultdict  # Retourne le dictionnaire de vulnérabilités simplifiées


def simplify_vulnnmap2(vulnnmap):
    resultdict = {}
    for key, value in vulnnmap.items():
        resultlist = []
        if value:
            # pour chaque vulnérabilité dans la liste des vulnérabilités associée à la clé
            # on extrait la partie après le premier ':' (inclus) et on l'ajoute à une liste
            resultlist = [vuln.split(':')[1:] for vuln in value]
            resultdict[key] = resultlist
        else:
            # si la liste est vide, on ajoute une liste vide à la place
            resultdict[key] = []
    return resultdict


def converttotable(var_dict):
    outvalue = ''
    for key in var_dict.keys():
        # Séparer la clé en deux parties: l'adresse IP et le service associé
        ip_address = key.split(' ')[0]
        service = ''.join(key.split(' ')[1::])
        # Ajouter la ligne à la sortie
        outvalue += '| {ip}| {service}|\n'.format(ip=ip_address, service=service)
    return outvalue


def passwrdformattotable(pass_list):
    foundoutvalue = ''  # Initialisation de la variable de sortie pour les résultats trouvés
    notfoundoutvalue = ''  # Initialisation de la variable de sortie pour les résultats non trouvés

    # Boucle à travers la liste des mots de passe
    for value in pass_list:
        service = value[0]  # Service pour lequel le mot de passe a été trouvé
        passwd = value[1]  # Le mot de passe trouvé
        servicePort = (service.split(':')[1]).split(' ')[0]  # Le port du service
        serviceServer = (service.split(':')[0])  # Le serveur sur lequel le service est exécuté

        # Si un mot de passe a été trouvé
        if passwd:
            login = passwd[0]  # Nom d'utilisateur associé au mot de passe
            mdp = passwd[1]  # Le mot de passe proprement dit
            foundoutvalue += f'| {serviceServer} | {servicePort} | {login}/{mdp} |'  # Ajouter les résultats trouvés à la variable de sortie
        else:
            notfoundoutvalue += f'| {serviceServer} | {servicePort} | Not Found |'  # Ajouter les résultats non trouvés à la variable de sortie

    return foundoutvalue, notfoundoutvalue  # Retourner les résultats trouvés et non trouvés


def format_vulnmap(vulnnmap):
    # initialisation de la chaine de caractères retournée
    retunvalue = ''

    # parcours des clés et des valeurs de vulnnmap
    for key, value in vulnnmap.items():
        if value:
            # Ajout des informations de la clé et de la liste de vulnérabilités
            # à la chaine de caractères retournée, avec un formatage approprié
            retunvalue += ' - {key}\n\t- {value}\n'.format(key='{}'.format(key), value='\n\t- '.join(value))

    # Retourne la chaine de caractères formatée
    return retunvalue


def generate_markdown(nmap, pass_list=None):
    # Ouvrir le fichier AUDIT_TEMPLATE.md et l'utiliser pour initialiser outvalue avec les valeurs de nmap
    with open('AUDIT_TEMPLATE/AUDIT_TEMPLATE.md', 'r') as f:
        outvalue = (f.read().format(networklist=list2graphical(nmap.all_hosts()), listeIPtable=nmap2table(nmap)))

    # Générer la liste des vulnérabilités avec la fonction vulnnmap
    listvuln = vulnnmap(nmap)

    # Si des vulnérabilités sont trouvées, les simplifier et les mettre en forme dans un tableau
    if not all(val == False for val in [bool(i) for i in list(listvuln.values())]):
        simplified_listvuln = simplify_vulnnmap(listvuln)
        table_listvuln = converttotable(simplified_listvuln)
        # Ouvrir le fichier AUDIT_TEMPLATE_VULN.md et l'utiliser pour ajouter les vulnérabilités à outvalue
        with open('AUDIT_TEMPLATE/AUDIT_TEMPLATE_VULN.md', 'r') as f:
            outvalue += (f.read().format(vulnlist=format_vulnmap(listvuln), tableupdate=table_listvuln))

    # Si une liste de mots de passe est fournie, les mettre en forme dans un tableau
    if pass_list:
        with open('AUDIT_TEMPLATE/AUDIT_TEMPLATE_PASSWRD.md', 'r') as f:
            passwrd = passwrdformattotable(pass_list)
            found = passwrd[0]
            notfound = passwrd[1]
            allservice = '\n - ' + '\n - '.join((found + notfound)[0])
            # Ouvrir le fichier AUDIT_TEMPLATE_PASSWRD.md et l'utiliser pour ajouter les mots de passe à outvalue
            outvalue += (f.read().format(servicelist=allservice, serviceFound=found, servicenotFound=notfound))

    return outvalue


def markdown4pdf(source, destination):
    # Convertit le contenu Markdown en PDF en utilisant md2pdfmodule
    # md_content : le contenu Markdown à convertir en PDF
    # md_file_path : le chemin du fichier Markdown à convertir en PDF
    # css_file_path : le chemin du fichier CSS à utiliser pour le style du document PDF
    # base_url : l'URL de base pour les images et autres ressources externes dans le document
    md2pdfmodule(destination,
                 md_content=source,
                 md_file_path=None,
                 css_file_path='AUDIT_TEMPLATE/doc.css',
                 base_url=None)


if __name__ == "__main__":
    import nmap
    import ScanPort

    network2scan = "192.168.243.128"
    scan = ScanPort.NmapC(network2scan)

    print(
        markdown4pdf(generate_markdown(scan), '/home/user/toto.pdf')
    )
